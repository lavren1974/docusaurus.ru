---
description: Как Docusaurus собирает ваше приложение
---

# Архитектура

```mdx-code-block
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Zoom from '@site/src/components/Zoom';
```

<Zoom>

![Общее представление архитектуры](/img/architecture.png)

</Zoom>

Эта диаграмма показывает, как устроена сборка приложения на Docusaurus. Каждый из плагинов собирает свои данные и прокидывает их дальше в JSON формате; темы предоставляют компоненты интерфейса, которые получают данные в JSON формате в качестве роут-модулей. Сборщик собирает все эти компоненты и генерирует два бандла: серверный и клиентский.

Хотя вы (авторы плагинов и разработчики сайтов) постоянно пишете на JavaScript, имейте в виду, что код приложения на самом деле выполняется в разных средах:

- Все плагины жизненного цикла запускаются в Node. Поэтому, пока мы не начнем поддерживать ES-модули, исходный код плагина должен экспортироваться как CommonJS-модуль, который будет подключаться через `require`.
- Компоненты интерфейса же собирает Webpack. Они могут быть предоставлены как ES-модули — в соответствии с правилами импорта компонентов в React.

Плагины никогда не пересекаются с компонентами интерфейса напрямую в коде: они общаются только через протоколы (в нашем случае, через временные JSON-файлы и вызовы `addRoute`). Для лучшего понимания процесса сборки попробуйте представить, будто плагины написаны не на JavaScript, а на другом языке, наподобие Rust. Для пользователя единственный способ взаимодействия с плагинами - через `docusaurus.config.js`, который запускается в Node (следовательно, вы можете использовать `require` и передавать коллбеки в качестве опций плагина).

Во время сборки конфигурационный файл сериализуется и попадает в бандл, благодаря этому у компонентов интерфейса есть доступ к опциям конфига, например `themeConfig` или `baseUrl` через [`useDocusaurusaurusContext()`](../docusaurus-core.md#useDocusaurusContext). Несмотря на это, объект `siteConfig` содержит только **сериализованные значения** (значения, которые сохраняются после `JSON.stringify()`). Функции, регулярные выражения и т.д. будут потеряны на клиентской стороне. `themeConfig` специально разработан для того, чтобы быть полностью сериализуемым.
